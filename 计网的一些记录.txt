1、有关TCP三次握手四次挥手的相关博客：
a) https://blog.csdn.net/qq_38950316/article/details/81087809
b) https://blog.csdn.net/b954960630/article/details/81861579
c) https://blog.csdn.net/lengxiao1993/article/details/82771768?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.compare&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.compare

个人感觉第三个博客针对TCP三次握手而不是两次握手的分析更好一些，如下：
      目前大部分人的分析是“防止已失效的连接请求又传送到服务器端，因而产生错误”，但根本原因我觉得还是因为TCP是可靠传输，只有三次握手才能保证其可靠性，两次握手并不能，作者也提到：为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤，如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。

此外，关于“防止已失效的连接请求又传送到服务器端，因而产生错误”的解释：
      假定A向B发送一个连接请求，由于一些原因，导致A发出的连接请求在一个网络节点逗留了比较多的时间。此时A会将此连接请求作为无效处理 又重新向B发起了一次新的连接请求，B正常收到此连接请求后建立了连接，数据传输完成后释放了连接。如果此时A发出的第一次请求又到达了B，B会以为A又发起了一次连接请求，如果是两次握手：此时连接就建立了，B会一直等待A发送数据，从而白白浪费B的资源。 如果是三次握手：由于A没有发起连接请求，也就不会理会B的连接响应，B没有收到A的确认连接，就会关闭掉本次连接。

个人理解：为什么三次握手时，由于A没有发起连接请求，也就不会理会B的连接响应，B没有收到A的确认连接，就会关闭掉本次连接，那两次握手时，B为什么要一直等待A发送数据，从而白白浪费B的资源呢？ 三次握手时，如果客户端挂了，服务器长时间没有数据还会发送探测报文来探测客户端有没有问题，从而决定是否关闭连接，两次握手也完全可以这样，如果长时间收不到数据就关闭连接。所以我觉得三次握手而不是两次握手的根本原因还是因为TCP是可靠传输，只有三次握手才能保证其可靠性，两次握手并不能。
